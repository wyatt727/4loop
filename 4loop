#!/usr/bin/env python3
import sys, os, time, re
from itertools import cycle

def parse_input(source):
    """Parse an input source into a list of lines."""
    if source == "INPUT":
        return [line.rstrip() for line in sys.stdin.readlines()]
    elif source.isdigit():
        # For numeric input, return indices 1 to N for backward compatibility
        return [str(i+1) for i in range(int(source))]
    elif os.path.isfile(source):
        with open(source, 'r') as f:
            return [line.rstrip() for line in f.readlines()]
    else:
        return None

def parse_timeout(arg):
    """Parse a timeout value. Returns (is_timeout, timeout_value)."""
    # Check for explicit time suffixes
    match = re.match(r'^(\d*\.?\d+)(ms|s)?$', arg)
    if not match:
        return False, None
    
    num_str, suffix = match.groups()
    try:
        value = float(num_str)
        if suffix == 'ms':
            return True, value / 1000.0
        elif suffix == 's':
            return True, value
        # No suffix - could be timeout or input, return the value for further logic
        return None, value  # None means "maybe timeout"
    except ValueError:
        return False, None

def is_valid_input(source):
    """Check if something could be a valid input source."""
    # Don't treat explicit timeouts as inputs
    is_timeout, _ = parse_timeout(source)
    if is_timeout:
        return False
    return source == "INPUT" or source.isdigit() or os.path.isfile(source)

def replace_vars(cmd, values):
    """Replace LINE variables intelligently based on number of values."""
    if len(values) == 1:
        # Single input: all variants map to same value
        cmd = cmd.replace("LINE2", values[0])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    else:
        # Two inputs: LINE2->second, LINE1->first, LINE->first
        cmd = cmd.replace("LINE2", values[1])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    return cmd

def main():
    args = sys.argv[1:]
    
    if len(args) < 2:
        print("Usage: 4loop [-z|-c] '[command]' [input1] [input2] [timeout]")
        print("  -z: Zip mode (pair lines 1:1, stop at shortest)")
        print("  -c: Cycle mode (repeat shorter file to match longer)")
        print("  default: Cartesian product (all combinations)")
        print("\nTimeout can use suffixes: 3s (seconds), 500ms (milliseconds)")
        print("\nExamples:")
        print("  4loop 'echo LINE' file.txt")
        print("  4loop 'echo LINE' 5 3s          # 5 iterations, 3 second timeout")
        print("  4loop 'curl LINE1:LINE2' hosts.txt ports.txt 500ms")
        print("  seq 1 5 | 4loop 'echo LINE' INPUT 2s")
        sys.exit(1)
    
    # Parse mode flag
    mode = 'cartesian'
    if args[0] in ['-z', '-c']:
        mode = 'zip' if args[0] == '-z' else 'cycle'
        args = args[1:]
        
    # Ensure we still have enough args after flag parsing
    if len(args) < 2:
        print("Error: Not enough arguments after mode flag")
        sys.exit(1)
    
    cmd = args[0]
    remaining = args[1:]
    
    # Smart parsing: identify inputs vs timeout
    inputs = []
    timeout = 0.075
    timeout_found = False
    
    for i, arg in enumerate(remaining):
        # First check if this is explicitly a timeout (has s/ms suffix)
        is_timeout, timeout_value = parse_timeout(arg)
        
        if is_timeout is True:
            # Explicit timeout with suffix
            timeout = timeout_value
            timeout_found = True
            # Continue processing remaining args as inputs if before this arg
            continue
        
        # If we already found a timeout, this must be an error
        if timeout_found:
            print(f"Error: Unexpected argument '{arg}' after timeout")
            sys.exit(1)
        
        # Check if it could be a valid input
        if is_valid_input(arg):
            inputs.append(arg)
            # Stop at 2 inputs max
            if len(inputs) >= 2:
                # Check if there's a timeout after
                if i < len(remaining) - 1:
                    next_is_timeout, next_timeout = parse_timeout(remaining[i + 1])
                    if next_is_timeout is True:
                        timeout = next_timeout
                    elif next_is_timeout is None:
                        # Ambiguous number - treat as timeout since we have 2 inputs
                        timeout = next_timeout
                    else:
                        print(f"Error: '{remaining[i + 1]}' is not a valid timeout")
                        sys.exit(1)
                break
        else:
            # Not a valid input - might be timeout without suffix if last arg
            if i == len(remaining) - 1 and inputs:
                # Try to parse as timeout
                maybe_timeout, value = parse_timeout(arg)
                if maybe_timeout is None:  # Numeric without suffix
                    # Treat as timeout if: has decimal, is 0, or we have INPUT
                    if '.' in arg or value == 0 or inputs == ['INPUT']:
                        timeout = value
                    else:
                        # Ambiguous - could be input or timeout
                        # If command uses LINE2, probably want two inputs
                        if 'LINE2' in cmd:
                            inputs.append(arg)
                        else:
                            # Otherwise treat as timeout for backward compat
                            timeout = value
                else:
                    print(f"Error: '{arg}' is not a valid input or timeout")
                    sys.exit(1)
            else:
                print(f"Error: '{arg}' is not a valid input source")
                sys.exit(1)
    
    # Must have at least one input  
    if not inputs:
        print("Error: No input source provided")
        sys.exit(1)
    
    # Parse input sources
    lists = []
    for inp in inputs:
        parsed = parse_input(inp)
        if parsed is None:
            print(f"Error: '{inp}' is not a valid file, number, or INPUT")
            sys.exit(1)
        if not parsed:  # Empty file/input
            print(f"Warning: '{inp}' is empty")
            continue
        lists.append(parsed)
    
    if not lists:
        print("Error: All input sources are empty")
        sys.exit(1)
    
    # Execute based on number of inputs and mode
    if len(lists) == 1:
        # Single input - simple iteration (backward compatible)
        for line in lists[0]:
            exec_cmd = replace_vars(cmd, [line])
            os.system(exec_cmd)
            time.sleep(timeout)
    
    elif len(lists) == 2:
        # Two inputs - use specified mode
        if mode == 'cartesian':
            # All combinations (default)
            for line1 in lists[0]:
                for line2 in lists[1]:
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
        
        elif mode == 'zip':
            # Pair lines 1:1, stop at shortest
            for line1, line2 in zip(lists[0], lists[1]):
                exec_cmd = replace_vars(cmd, [line1, line2])
                os.system(exec_cmd)
                time.sleep(timeout)
        
        elif mode == 'cycle':
            # Cycle shorter list to match longer
            if len(lists[0]) >= len(lists[1]):
                # Cycle second list
                cycled = cycle(lists[1])
                for line1 in lists[0]:
                    line2 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
            else:
                # Cycle first list
                cycled = cycle(lists[0])
                for line2 in lists[1]:
                    line1 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
    else:
        print("Error: Maximum 2 input sources supported")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted")
        sys.exit(130)
    except BrokenPipeError:
        # Handle pipe closure gracefully
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)