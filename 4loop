#!/usr/bin/env python3
import sys, os, time
from itertools import cycle

def parse_input(source):
    """Parse an input source into a list of lines."""
    if source == "INPUT":
        return [line.rstrip() for line in sys.stdin.readlines()]
    elif source.isdigit():
        # For numeric input, return indices 1 to N for backward compatibility
        return [str(i+1) for i in range(int(source))]
    elif os.path.isfile(source):
        with open(source, 'r') as f:
            return [line.rstrip() for line in f.readlines()]
    else:
        return None

def is_valid_input(source):
    """Check if something could be a valid input source."""
    return source == "INPUT" or source.isdigit() or os.path.isfile(source)

def replace_vars(cmd, values):
    """Replace LINE variables intelligently based on number of values."""
    if len(values) == 1:
        # Single input: all variants map to same value
        cmd = cmd.replace("LINE2", values[0])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    else:
        # Two inputs: LINE2->second, LINE1->first, LINE->first
        cmd = cmd.replace("LINE2", values[1])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    return cmd

def main():
    args = sys.argv[1:]
    
    if len(args) < 2:
        print("Usage: 4loop [-z|-c] '[command]' [input1] [input2] [timeout]")
        print("  -z: Zip mode (pair lines 1:1, stop at shortest)")
        print("  -c: Cycle mode (repeat shorter file to match longer)")
        print("  default: Cartesian product (all combinations)")
        print("\nExamples:")
        print("  4loop 'echo LINE' file.txt")
        print("  4loop 'curl LINE1:LINE2' hosts.txt ports.txt")
        print("  seq 1 5 | 4loop 'echo LINE' INPUT")
        print("  4loop -z 'ssh LINE1 \"test LINE2\"' users.txt passwords.txt 0.5")
        sys.exit(1)
    
    # Parse mode flag
    mode = 'cartesian'
    if args[0] in ['-z', '-c']:
        mode = 'zip' if args[0] == '-z' else 'cycle'
        args = args[1:]
        
    # Ensure we still have enough args after flag parsing
    if len(args) < 2:
        print("Error: Not enough arguments after mode flag")
        sys.exit(1)
    
    cmd = args[0]
    remaining = args[1:]
    
    # Parse inputs and timeout more intelligently
    inputs = []
    timeout = 0.075
    
    # Collect valid inputs from left to right
    for i, arg in enumerate(remaining):
        if is_valid_input(arg):
            inputs.append(arg)
        else:
            # Not a valid input - might be timeout if it's the last arg
            if i == len(remaining) - 1:
                try:
                    timeout = float(arg)
                except ValueError:
                    print(f"Error: '{arg}' is not a valid input or timeout")
                    sys.exit(1)
            else:
                print(f"Error: '{arg}' is not a valid input source")
                sys.exit(1)
            break
    
    # Special case: if we have valid inputs and the last arg is numeric,
    # decide if it's timeout or another input
    if inputs and len(remaining) > len(inputs):
        last_arg = remaining[-1]
        try:
            potential_timeout = float(last_arg)
            # Rules for treating last numeric as timeout:
            # 1. If INPUT is present and this would be the only other arg -> timeout
            # 2. If we already have 2 inputs -> timeout
            # 3. If it has a decimal point -> timeout
            # 4. If it's 0 -> timeout (common for "no delay")
            # 5. Otherwise -> treat as input
            if (('INPUT' in inputs and len(inputs) == 1) or
                len(inputs) >= 2 or
                '.' in last_arg or
                potential_timeout == 0):
                timeout = potential_timeout
                # Remove the last item from inputs if we added it
                if last_arg in inputs:
                    inputs.pop()
        except ValueError:
            pass
    
    # Must have at least one input  
    if not inputs:
        print("Error: No input source provided")
        sys.exit(1)
    
    # Parse input sources
    lists = []
    for inp in inputs:
        parsed = parse_input(inp)
        if parsed is None:
            print(f"Error: '{inp}' is not a valid file, number, or INPUT")
            sys.exit(1)
        if not parsed:  # Empty file/input
            print(f"Warning: '{inp}' is empty")
            continue
        lists.append(parsed)
    
    if not lists:
        print("Error: All input sources are empty")
        sys.exit(1)
    
    # Execute based on number of inputs and mode
    if len(lists) == 1:
        # Single input - simple iteration (backward compatible)
        for line in lists[0]:
            exec_cmd = replace_vars(cmd, [line])
            os.system(exec_cmd)
            time.sleep(timeout)
    
    elif len(lists) == 2:
        # Two inputs - use specified mode
        if mode == 'cartesian':
            # All combinations (default)
            for line1 in lists[0]:
                for line2 in lists[1]:
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
        
        elif mode == 'zip':
            # Pair lines 1:1, stop at shortest
            for line1, line2 in zip(lists[0], lists[1]):
                exec_cmd = replace_vars(cmd, [line1, line2])
                os.system(exec_cmd)
                time.sleep(timeout)
        
        elif mode == 'cycle':
            # Cycle shorter list to match longer
            if len(lists[0]) >= len(lists[1]):
                # Cycle second list
                cycled = cycle(lists[1])
                for line1 in lists[0]:
                    line2 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
            else:
                # Cycle first list
                cycled = cycle(lists[0])
                for line2 in lists[1]:
                    line1 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
    else:
        print("Error: Maximum 2 input sources supported")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted")
        sys.exit(130)
    except BrokenPipeError:
        # Handle pipe closure gracefully
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)