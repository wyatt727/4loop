#!/usr/bin/env python3
import sys, os, time
from itertools import cycle

def parse_input(source):
    """Parse an input source into a list of lines."""
    if source == "INPUT":
        return [line.rstrip() for line in sys.stdin.readlines()]
    elif source.isdigit():
        # For numeric input, return indices 1 to N for backward compatibility
        return [str(i+1) for i in range(int(source))]
    elif os.path.isfile(source):
        with open(source, 'r') as f:
            return [line.rstrip() for line in f.readlines()]
    else:
        return None

def is_valid_input(source):
    """Check if something could be a valid input source."""
    return source == "INPUT" or source.isdigit() or os.path.isfile(source)

def replace_vars(cmd, values):
    """Replace LINE variables intelligently based on number of values."""
    if len(values) == 1:
        # Single input: all variants map to same value
        cmd = cmd.replace("LINE2", values[0])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    else:
        # Two inputs: LINE2->second, LINE1->first, LINE->first
        cmd = cmd.replace("LINE2", values[1])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    return cmd

def main():
    args = sys.argv[1:]
    
    if len(args) < 2:
        print("Usage: 4loop [-z|-c] '[command]' [input1] [input2] [timeout]")
        print("  -z: Zip mode (pair lines 1:1, stop at shortest)")
        print("  -c: Cycle mode (repeat shorter file to match longer)")
        print("  default: Cartesian product (all combinations)")
        print("\nExamples:")
        print("  4loop 'echo LINE' file.txt")
        print("  4loop 'curl LINE1:LINE2' hosts.txt ports.txt")
        print("  seq 1 5 | 4loop 'echo LINE' INPUT")
        print("  4loop -z 'ssh LINE1 \"test LINE2\"' users.txt passwords.txt 0.5")
        sys.exit(1)
    
    # Parse mode flag
    mode = 'cartesian'
    if args[0] in ['-z', '-c']:
        mode = 'zip' if args[0] == '-z' else 'cycle'
        args = args[1:]
        
    # Ensure we still have enough args after flag parsing
    if len(args) < 2:
        print("Error: Not enough arguments after mode flag")
        sys.exit(1)
    
    cmd = args[0]
    remaining = args[1:]
    
    # Smart parsing: identify inputs vs timeout
    inputs = []
    timeout = 0.075
    
    for i, arg in enumerate(remaining):
        # Check if this should be treated as timeout
        should_be_timeout = False
        
        if i == len(remaining) - 1:  # Last argument
            try:
                potential_timeout = float(arg)
                # Treat as timeout if:
                # 1. We already have at least one input AND
                # 2. Either: it has a decimal, OR it's 0, OR we have INPUT and this is numeric
                if inputs and ('.' in arg or 
                              potential_timeout == 0 or 
                              (inputs == ['INPUT'] and arg.replace('.','').replace('-','').isdigit())):
                    should_be_timeout = True
            except ValueError:
                pass
        
        if should_be_timeout:
            timeout = float(arg)
            break
        elif is_valid_input(arg):
            inputs.append(arg)
            # Stop at 2 inputs max
            if len(inputs) >= 2:
                # Check if there's a timeout after
                if i < len(remaining) - 1:
                    try:
                        timeout = float(remaining[i + 1])
                    except ValueError:
                        print(f"Error: '{remaining[i + 1]}' is not a valid timeout")
                        sys.exit(1)
                break
        else:
            # Not a valid input and not the last arg that could be timeout
            print(f"Error: '{arg}' is not a valid input source")
            sys.exit(1)
    
    # Must have at least one input  
    if not inputs:
        print("Error: No input source provided")
        sys.exit(1)
    
    # Parse input sources
    lists = []
    for inp in inputs:
        parsed = parse_input(inp)
        if parsed is None:
            print(f"Error: '{inp}' is not a valid file, number, or INPUT")
            sys.exit(1)
        if not parsed:  # Empty file/input
            print(f"Warning: '{inp}' is empty")
            continue
        lists.append(parsed)
    
    if not lists:
        print("Error: All input sources are empty")
        sys.exit(1)
    
    # Execute based on number of inputs and mode
    if len(lists) == 1:
        # Single input - simple iteration (backward compatible)
        for line in lists[0]:
            exec_cmd = replace_vars(cmd, [line])
            os.system(exec_cmd)
            time.sleep(timeout)
    
    elif len(lists) == 2:
        # Two inputs - use specified mode
        if mode == 'cartesian':
            # All combinations (default)
            for line1 in lists[0]:
                for line2 in lists[1]:
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
        
        elif mode == 'zip':
            # Pair lines 1:1, stop at shortest
            for line1, line2 in zip(lists[0], lists[1]):
                exec_cmd = replace_vars(cmd, [line1, line2])
                os.system(exec_cmd)
                time.sleep(timeout)
        
        elif mode == 'cycle':
            # Cycle shorter list to match longer
            if len(lists[0]) >= len(lists[1]):
                # Cycle second list
                cycled = cycle(lists[1])
                for line1 in lists[0]:
                    line2 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
            else:
                # Cycle first list
                cycled = cycle(lists[0])
                for line2 in lists[1]:
                    line1 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
    else:
        print("Error: Maximum 2 input sources supported")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted")
        sys.exit(130)
    except BrokenPipeError:
        # Handle pipe closure gracefully
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)