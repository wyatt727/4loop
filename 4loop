#!/usr/bin/env python3
import sys, os, time
from itertools import product, cycle

def parse_input(source):
    """Parse an input source into a list of lines."""
    if source == "INPUT":
        return [line.rstrip() for line in sys.stdin.readlines()]
    elif source.isdigit():
        # For numeric input, return indices 1 to N for backward compatibility
        return [str(i+1) for i in range(int(source))]
    elif os.path.isfile(source):
        with open(source, 'r') as f:
            return [line.rstrip() for line in f.readlines()]
    else:
        return None

def replace_vars(cmd, values):
    """Replace LINE variables intelligently based on number of values."""
    if len(values) == 1:
        # Single input: all variants map to same value
        cmd = cmd.replace("LINE2", values[0])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    else:
        # Two inputs: LINE2->second, LINE1->first, LINE->first
        cmd = cmd.replace("LINE2", values[1])
        cmd = cmd.replace("LINE1", values[0])
        cmd = cmd.replace("LINE", values[0])
    return cmd

def main():
    args = sys.argv[1:]
    
    if len(args) < 2:
        print("Usage: 4loop [-z|-c] '[command]' [input1] [input2] [timeout]")
        print("  -z: Zip mode (pair lines 1:1, stop at shortest)")
        print("  -c: Cycle mode (repeat shorter file to match longer)")
        print("  default: Cartesian product (all combinations)")
        print("\nExamples:")
        print("  4loop 'echo LINE' file.txt")
        print("  4loop 'curl LINE1:LINE2' hosts.txt ports.txt")
        print("  4loop -z 'ssh LINE1 \"test LINE2\"' users.txt passwords.txt")
        sys.exit(1)
    
    # Parse mode flag
    mode = 'cartesian'
    if args[0] in ['-z', '-c']:
        mode = 'zip' if args[0] == '-z' else 'cycle'
        args = args[1:]
        
    # Ensure we still have enough args after flag parsing
    if len(args) < 2:
        print("Error: Not enough arguments after mode flag")
        sys.exit(1)
    
    cmd = args[0]
    remaining = args[1:]
    
    # Parse timeout (if last arg is a float)
    timeout = 0.075
    inputs = []
    
    if remaining:
        # Check if we have multiple args and last one could be timeout
        if len(remaining) > 1:
            try:
                # Try to parse last arg as timeout
                potential_timeout = float(remaining[-1])
                # Only treat as timeout if it's not a valid input source
                if not os.path.isfile(remaining[-1]) and not remaining[-1].isdigit() and remaining[-1] != "INPUT":
                    timeout = potential_timeout
                    inputs = remaining[:-1]
                else:
                    inputs = remaining
            except ValueError:
                inputs = remaining
        else:
            # Single remaining arg is always input, never timeout
            inputs = remaining
    
    # Must have at least one input  
    if not inputs:
        print("Error: No input source provided")
        sys.exit(1)
    
    # Parse input sources
    lists = []
    for inp in inputs:
        parsed = parse_input(inp)
        if parsed is None:
            print(f"Error: '{inp}' is not a valid file, number, or INPUT")
            sys.exit(1)
        if not parsed:  # Empty file
            print(f"Warning: '{inp}' is empty")
            continue
        lists.append(parsed)
    
    if not lists:
        print("Error: All input sources are empty")
        sys.exit(1)
    
    # Execute based on number of inputs and mode
    if len(lists) == 1:
        # Single input - simple iteration (backward compatible)
        for line in lists[0]:
            exec_cmd = replace_vars(cmd, [line])
            os.system(exec_cmd)
            time.sleep(timeout)
    
    elif len(lists) == 2:
        # Two inputs - use specified mode
        if mode == 'cartesian':
            # All combinations (default)
            for line1 in lists[0]:
                for line2 in lists[1]:
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
        
        elif mode == 'zip':
            # Pair lines 1:1, stop at shortest
            for line1, line2 in zip(lists[0], lists[1]):
                exec_cmd = replace_vars(cmd, [line1, line2])
                os.system(exec_cmd)
                time.sleep(timeout)
        
        elif mode == 'cycle':
            # Cycle shorter list to match longer
            if len(lists[0]) >= len(lists[1]):
                # Cycle second list
                cycled = cycle(lists[1])
                for line1 in lists[0]:
                    line2 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
            else:
                # Cycle first list
                cycled = cycle(lists[0])
                for line2 in lists[1]:
                    line1 = next(cycled)
                    exec_cmd = replace_vars(cmd, [line1, line2])
                    os.system(exec_cmd)
                    time.sleep(timeout)
    else:
        print("Error: Maximum 2 input sources supported")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted")
        sys.exit(130)
    except BrokenPipeError:
        # Handle pipe closure gracefully
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)